<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OSGB36(15) Grid + Boundary → DXF</title>

  <!-- Leaflet -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>

  <!-- Geocoder -->
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Proj4 + GeoTIFF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.19.0/proj4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>

  <style>
    :root { --pad: 12px; --radius: 16px; }
    html, body { height: 100%; margin: 0; background: #0b0f19; }
    #map { height: 100%; width: 100%; }

    /* Ensure Leaflet controls (search/zoom) sit above the sheet and are tappable */
    .leaflet-top, .leaflet-bottom { z-index: 10050 !important; }

    /* --- Draggable bottom sheet --- */
    .sheet {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 9999;
      background: rgba(255,255,255,0.96);
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      box-shadow: 0 -12px 24px rgba(0,0,0,0.25);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      height: 78vh;
      transform: translateY(44vh);
      transition: transform 180ms ease;
      will-change: transform;

      padding: var(--pad);
      padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom));
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .handle {
      width: 54px;
      height: 6px;
      background: #d1d5db;
      border-radius: 999px;
      margin: 6px auto 12px auto;
      touch-action: none;
    }

    .sheet.is-collapsed { overflow: hidden; }
    .sheet.is-collapsed .mini,
    .sheet.is-collapsed .status { display: none; }

    @media (hover: hover) { .handle { cursor: ns-resize; } }

    .toprow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .title { font-weight: 900; font-size: 16px; }
    .badge {
      font-size: 12px;
      background: #e5e7eb;
      padding: 4px 10px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .field {
      background: #f3f4f6;
      border-radius: 14px;
      padding: 10px;
    }
    .field label {
      display: block;
      font-size: 12px;
      color: #374151;
      margin-bottom: 6px;
    }
    .field input[type="number"], .field input[type="text"] {
      width: 100%;
      font-size: 16px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #d1d5db;
      outline: none;
      box-sizing: border-box;
      background: white;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .btn {
      flex: 1;
      padding: 12px 12px;
      font-size: 15px;
      font-weight: 800;
      border: 0;
      border-radius: 14px;
      background: #111827;
      color: white;
      touch-action: manipulation;
    }
    .btn.secondary { background: #4b5563; }
    .btn.danger { background: #991b1b; }
    .btn:disabled { opacity: 0.55; }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #111827;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      padding: 10px;
      border-radius: 14px;
    }

    .mini {
      margin-top: 8px;
      font-size: 12px;
      color: #374151;
      line-height: 1.35;
    }

    /* Crosshair overlay (optional) */
    .crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 36px;
      height: 36px;
      transform: translate(-50%, -50%);
      z-index: 6000;
      pointer-events: none;
      display: none;
    }
    .crosshair:before, .crosshair:after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 1px 4px rgba(0,0,0,0.35);
    }
    .crosshair:before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
    .crosshair:after  { top: 50%; left: 0; height: 2px; width: 100%; transform: translateY(-50%); }
    .crosshair .dot {
      position: absolute;
      left: 50%; top: 50%;
      width: 10px; height: 10px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
    }

    .toggle {
      display: flex; align-items: center; justify-content: space-between;
      background: #f3f4f6;
      border-radius: 14px;
      padding: 10px;
      margin-top: 10px;
      gap: 12px;
    }
    .toggle span { font-size: 13px; color: #111827; font-weight: 700; }
    .toggle input { transform: scale(1.3); }

    /* make leaflet controls bigger on mobile */
    .leaflet-control-zoom a { width: 40px; height: 40px; line-height: 40px; font-size: 18px; }
    .leaflet-control-geocoder { max-width: 70vw; }

    /* Grip icons (bigger + touch-friendly) */
    .grip {
      width: 26px; height: 26px;
      border-radius: 7px;
      border: 2px solid #111827;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 3px 12px rgba(0,0,0,0.28);
      touch-action: none;           /* key for smooth dragging */
      pointer-events: auto;
    }
    .rotgrip {
      width: 28px; height: 28px;
      border-radius: 999px;
      border: 2px solid #111827;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 3px 12px rgba(0,0,0,0.28);
      touch-action: none;
      pointer-events: auto;
      position: relative;
    }
    .rotgrip:after{
      content:"";
      position:absolute;
      left:50%; top:50%;
      width: 8px; height: 8px;
      transform: translate(-50%,-50%);
      border-radius: 999px;
      background:#111827;
      opacity:0.9;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="crosshair" id="crosshair"><div class="dot"></div></div>

  <div class="sheet" id="sheet">
    <div class="handle" id="handle" aria-label="Drag to resize"></div>

    <div class="toprow">
      <div class="title">OSGB36(15) Grid + Boundary → DXF</div>
      <div class="badge" id="modeBadge">centre pick</div>
    </div>

    <!-- ACTIONS FIRST -->
    <div class="row">
      <button class="btn" id="pickCentreBtn">Pick centre</button>
      <button class="btn secondary" id="pickRotateBtn">Pick rotation</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="gpsBtn">Use GPS for centre</button>
      <button class="btn" id="exportBtn" disabled>Export DXF</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="drawBoundaryBtn">Draw boundary</button>
      <button class="btn secondary" id="finishBoundaryBtn" disabled>Finish boundary</button>
      <button class="btn danger" id="clearBoundaryBtn" disabled>Clear boundary</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="resetBtn">Reset</button>
    </div>

    <!-- OPTIONS -->
    <div class="toggle">
      <span>Use crosshair to pick points</span>
      <input id="useCrosshair" type="checkbox" />
    </div>

    <div class="toggle">
      <span>Export relative to centre</span>
      <input id="relativeExport" type="checkbox" />
    </div>

    <div class="toggle">
      <span>Auto align to true north</span>
      <input id="autoNorth" type="checkbox" checked />
    </div>

    <!-- GRID SETTINGS LOWER DOWN -->
    <div class="grid2" style="margin-top:10px;">
      <div class="field">
        <label for="gridWidth">Grid width (m)</label>
        <input id="gridWidth" type="number" min="1" step="1" value="300" />
      </div>
      <div class="field">
        <label for="gridHeight">Grid height (m)</label>
        <input id="gridHeight" type="number" min="1" step="1" value="300" />
      </div>
      <div class="field">
        <label for="gridSpacing">Line spacing (m)</label>
        <input id="gridSpacing" type="number" min="0.1" step="0.1" value="10" />
      </div>
      <div class="field">
        <label for="layerName">Grid layer (DXF)</label>
        <input id="layerName" type="text" value="GRID" />
      </div>
      <div class="field">
        <label>Rotation (deg)</label>
        <div style="font-size:16px;font-weight:900;" id="rotDeg">0.000</div>
      </div>
      <div class="field">
        <label for="boundaryLayerName">Boundary layer (DXF)</label>
        <input id="boundaryLayerName" type="text" value="BOUNDARY" />
      </div>
    </div>

    <div class="status" id="statusBox">Loading OSTN15 grid…</div>
    <div class="mini">
      Grips: drag corners to stretch rectangle, drag round grip to rotate. Boundary: tap points, then Finish.
    </div>
  </div>

<script>
  // ---------------------------
  // Map setup (Satellite)
  // ---------------------------
  const map = L.map('map', { zoomControl: true }).setView([52.2, 0.9], 13);

  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 20, attribution: 'Tiles © Esri' }
  ).addTo(map);

  // geocoder: fit bounds reliably
  const geocodeControl = L.Control.geocoder({ defaultMarkGeocode: false }).addTo(map);
  geocodeControl.on('markgeocode', function(e) {
    map.fitBounds(e.geocode.bbox);
  });

  // ---------------------------
  // OSGB36(15) / OSTN15
  // ---------------------------
  const statusBox = document.getElementById('statusBox');
  const exportBtn = document.getElementById('exportBtn');

  const OSTN15_TIFF_URL = 'https://cdn.proj.org/uk_os_OSTN15_NTv2_OSGBtoETRS.tif';
  const EPSG27700_DEF_BASE =
    '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' +
    '+x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs +type=crs';

  proj4.defs('EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs +type=crs');

  let ostnReady = false;

  async function loadOSTN15() {
    try {
      statusBox.textContent = 'Loading OSTN15 grid (needs internet)…';
      const tiff = await GeoTIFF.fromUrl(OSTN15_TIFF_URL);
      await proj4.nadgrid('OSTN15_NTv2_OSGBtoETRS', tiff).ready;

      proj4.defs('EPSG:27700', EPSG27700_DEF_BASE + ' +nadgrids=OSTN15_NTv2_OSGBtoETRS');
      ostnReady = true;
      statusBox.textContent = 'OSTN15 loaded ✅ (OSGB36(15) accurate)';
      exportBtn.disabled = false;

      if (centreLatLng && autoNorthEl.checked && !userRotated) {
        rotationRad = trueNorthRotationRad(centreLatLng);
        updateRotationDisplay();
      }
      redrawAll();
    } catch (e) {
      console.error(e);
      statusBox.textContent =
        'OSTN15 failed to load ⚠️ Using rough fallback (not survey-grade). Host on GitHub Pages for best results.';
      proj4.defs(
        'EPSG:27700',
        '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' +
        '+x_0=400000 +y_0=-100000 +ellps=airy ' +
        '+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 ' +
        '+units=m +no_defs +type=crs'
      );
      ostnReady = false;
      exportBtn.disabled = false;

      if (centreLatLng && autoNorthEl.checked && !userRotated) {
        rotationRad = trueNorthRotationRad(centreLatLng);
        updateRotationDisplay();
      }
      redrawAll();
    }
  }
  loadOSTN15();

  // ---------------------------
  // State
  // ---------------------------
  let mode = 'centre'; // 'centre' | 'rotate' | 'boundary'
  let centreLatLng = null;

  let rotatePt1 = null;
  let rotatePt2 = null;
  let rotationRad = 0;

  // If user sets rotation (pick rotation or rotation grip), we stop auto-northing.
  let userRotated = false;

  let centreMarker = null;
  let rotateMarkers = [];

  let gridLayer = L.layerGroup().addTo(map);
  let gripLayer = L.layerGroup().addTo(map);

  // Boundary drawing
  let boundaryLatLngs = [];          // array of Leaflet latlngs
  let boundaryPreviewLine = null;    // Leaflet polyline
  let boundaryPointsLayer = L.layerGroup().addTo(map);

  const modeBadge = document.getElementById('modeBadge');
  const rotDegEl = document.getElementById('rotDeg');

  const gridWidthEl = document.getElementById('gridWidth');
  const gridHeightEl = document.getElementById('gridHeight');
  const gridSpacingEl = document.getElementById('gridSpacing');
  const layerNameEl = document.getElementById('layerName');
  const boundaryLayerNameEl = document.getElementById('boundaryLayerName');
  const relativeExportEl = document.getElementById('relativeExport');

  const useCrosshairEl = document.getElementById('useCrosshair');
  const crosshairEl = document.getElementById('crosshair');
  const autoNorthEl = document.getElementById('autoNorth');

  const drawBoundaryBtn = document.getElementById('drawBoundaryBtn');
  const finishBoundaryBtn = document.getElementById('finishBoundaryBtn');
  const clearBoundaryBtn = document.getElementById('clearBoundaryBtn');

  function setMode(m) {
    mode = m;
    modeBadge.textContent =
      (m === 'centre') ? 'centre pick' :
      (m === 'rotate') ? 'rotation pick' :
      'boundary draw';
  }

  function updateRotationDisplay() {
    rotDegEl.textContent = (rotationRad * 180 / Math.PI).toFixed(3);
  }

  function crosshairLatLng() {
    return map.getCenter();
  }

  // ---------------------------
  // Transforms
  // ---------------------------
  function latLngToEN(latlng) {
    const out = proj4('EPSG:4326', 'EPSG:27700', [latlng.lng, latlng.lat]);
    return { e: out[0], n: out[1] };
  }
  function enToLatLng(e, n) {
    const out = proj4('EPSG:27700', 'EPSG:4326', [e, n]);
    return L.latLng(out[1], out[0]);
  }

  function rotateAboutEN(e, n, ce, cn, ang) {
    const de = e - ce, dn = n - cn;
    const c = Math.cos(ang), s = Math.sin(ang);
    return { e: ce + de * c - dn * s, n: cn + de * s + dn * c };
  }

  function rotateVec(e, n, ang) {
    const c = Math.cos(ang), s = Math.sin(ang);
    return { e: e * c - n * s, n: e * s + n * c };
  }

  // True-north alignment:
  // Compute direction of "lat + tiny" in EN, then rotate grid so its +N matches that.
  function trueNorthRotationRad(latlng) {
    const dLat = 0.00015; // ~17m
    const p0 = latLngToEN(latlng);
    const pN = latLngToEN(L.latLng(latlng.lat + dLat, latlng.lng));
    const dE = pN.e - p0.e;
    const dN = pN.n - p0.n;
    const thetaFromEast = Math.atan2(dN, dE);
    return thetaFromEast - (Math.PI / 2);
  }

  // ---------------------------
  // Grid generation in EN (rectangle)
  // ---------------------------
  function buildGridLinesEN(centreEN, widthM, heightM, spacingM, angRad) {
    const halfW = widthM / 2;
    const halfH = heightM / 2;

    // steps for each axis (try to keep outer border exact)
    const stepsX = Math.max(1, Math.round(widthM / spacingM));
    const stepsY = Math.max(1, Math.round(heightM / spacingM));
    const stepX = widthM / stepsX;
    const stepY = heightM / stepsY;

    const lines = [];

    // vertical lines: x varies, y from -halfH to +halfH
    for (let i = 0; i <= stepsX; i++) {
      const x = -halfW + i * stepX;
      let e1 = centreEN.e + x, n1 = centreEN.n - halfH;
      let e2 = centreEN.e + x, n2 = centreEN.n + halfH;

      const a = rotateAboutEN(e1, n1, centreEN.e, centreEN.n, angRad);
      const b = rotateAboutEN(e2, n2, centreEN.e, centreEN.n, angRad);
      lines.push({ e1: a.e, n1: a.n, e2: b.e, n2: b.n });
    }

    // horizontal lines: y varies, x from -halfW to +halfW
    for (let j = 0; j <= stepsY; j++) {
      const y = -halfH + j * stepY;
      let e1 = centreEN.e - halfW, n1 = centreEN.n + y;
      let e2 = centreEN.e + halfW, n2 = centreEN.n + y;

      const a = rotateAboutEN(e1, n1, centreEN.e, centreEN.n, angRad);
      const b = rotateAboutEN(e2, n2, centreEN.e, centreEN.n, angRad);
      lines.push({ e1: a.e, n1: a.n, e2: b.e, n2: b.n });
    }

    return lines;
  }

  // ---------------------------
  // Grips: 4 corners (stretch) + 1 rotate
  // ---------------------------
  function makeDivIcon(className) {
    return L.divIcon({
      className: '',
      html: `<div class="${className}"></div>`,
      iconSize: [28, 28],
      iconAnchor: [14, 14]
    });
  }

  function stopIconFromStealingMapGestures(marker) {
    // Make dragging smooth on mobile: stop touch/pointer events bubbling to map
    marker.on('add', () => {
      const el = marker.getElement();
      if (!el) return;
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);

      // Stop pointer/touch events reaching the map (prevents “tap-tap” feeling)
      const stop = (e) => L.DomEvent.stopPropagation(e);
      ['pointerdown','pointermove','pointerup','touchstart','touchmove','touchend','mousedown','mousemove','mouseup']
        .forEach(evt => L.DomEvent.on(el, evt, stop));
    });
  }

  function setMapInteraction(enabled) {
    if (enabled) {
      map.dragging.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.touchZoom.enable();
    } else {
      map.dragging.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.touchZoom.disable();
    }
  }

  let cornerGrips = [];
  let rotateGrip = null;

  function clearGrips() {
    gripLayer.clearLayers();
    cornerGrips = [];
    rotateGrip = null;
  }

  function updateGrips() {
    clearGrips();
    if (!centreLatLng) return;

    const widthM = parseFloat(gridWidthEl.value);
    const heightM = parseFloat(gridHeightEl.value);
    if (!(widthM > 0) || !(heightM > 0)) return;

    const centreEN = latLngToEN(centreLatLng);
    const halfW = widthM / 2;
    const halfH = heightM / 2;

    // local (unrotated) corners
    const localCorners = [
      { x: -halfW, y: -halfH },
      { x:  halfW, y: -halfH },
      { x:  halfW, y:  halfH },
      { x: -halfW, y:  halfH }
    ];

    // place the 4 stretch grips
    localCorners.forEach((c) => {
      const p = rotateAboutEN(centreEN.e + c.x, centreEN.n + c.y, centreEN.e, centreEN.n, rotationRad);
      const ll = enToLatLng(p.e, p.n);

      const m = L.marker(ll, {
        draggable: true,
        icon: makeDivIcon('grip'),
        keyboard: false,
        autoPan: true,
        autoPanPadding: [40, 40]
      }).addTo(gripLayer);

      stopIconFromStealingMapGestures(m);

      m.on('dragstart', () => setMapInteraction(false));
      m.on('dragend', () => setMapInteraction(true));

      // Smooth stretch: project dragged point back into local axes
      m.on('drag', () => {
        const p2 = latLngToEN(m.getLatLng());
        const dE = p2.e - centreEN.e;
        const dN = p2.n - centreEN.n;

        // Rotate vector back by -rotationRad to get local coords
        const local = rotateVec(dE, dN, -rotationRad);

        const newHalfW = Math.max(0.5, Math.abs(local.e));
        const newHalfH = Math.max(0.5, Math.abs(local.n));

        gridWidthEl.value = Math.round(newHalfW * 2);
        gridHeightEl.value = Math.round(newHalfH * 2);

        redrawAll();
      });

      cornerGrips.push(m);
    });

    // rotation grip: above the top edge in local coords
    const rotOffset = Math.max(halfH * 1.25, 10);
    const rotEN = rotateAboutEN(centreEN.e, centreEN.n + rotOffset, centreEN.e, centreEN.n, rotationRad);
    const rotLL = enToLatLng(rotEN.e, rotEN.n);

    rotateGrip = L.marker(rotLL, {
      draggable: true,
      icon: makeDivIcon('rotgrip'),
      keyboard: false,
      autoPan: true,
      autoPanPadding: [40, 40]
    }).addTo(gripLayer);

    stopIconFromStealingMapGestures(rotateGrip);

    rotateGrip.on('dragstart', () => {
      userRotated = true;
      setMapInteraction(false);
    });
    rotateGrip.on('dragend', () => setMapInteraction(true));

    rotateGrip.on('drag', () => {
      const p = latLngToEN(rotateGrip.getLatLng());
      const dE = p.e - centreEN.e;
      const dN = p.n - centreEN.n;
      const thetaFromEast = Math.atan2(dN, dE);
      rotationRad = thetaFromEast - (Math.PI / 2);
      updateRotationDisplay();
      redrawAll();
    });
  }

  // ---------------------------
  // Boundary drawing (point to point)
  // ---------------------------
  function redrawBoundaryPreview() {
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPointsLayer.clearLayers();

    if (boundaryLatLngs.length === 0) {
      boundaryPreviewLine = null;
      finishBoundaryBtn.disabled = true;
      clearBoundaryBtn.disabled = true;
      return;
    }

    boundaryPreviewLine = L.polyline(boundaryLatLngs, { weight: 3, opacity: 0.9 }).addTo(map);

    // show small point markers
    boundaryLatLngs.forEach(ll => {
      L.circleMarker(ll, { radius: 5, weight: 2, opacity: 0.9, fillOpacity: 0.2 }).addTo(boundaryPointsLayer);
    });

    finishBoundaryBtn.disabled = boundaryLatLngs.length < 2;
    clearBoundaryBtn.disabled = false;
  }

  function startBoundaryMode() {
    setMode('boundary');
    drawBoundaryBtn.textContent = 'Add boundary points…';
    finishBoundaryBtn.disabled = boundaryLatLngs.length < 2;
    clearBoundaryBtn.disabled = boundaryLatLngs.length === 0;
  }

  function stopBoundaryMode() {
    setMode('centre');
    drawBoundaryBtn.textContent = 'Draw boundary';
  }

  // ---------------------------
  // Redraw all (grid + grips + boundary preview stays)
  // ---------------------------
  function redrawGrid() {
    gridLayer.clearLayers();
    if (!centreLatLng) { clearGrips(); return; }

    const widthM = parseFloat(gridWidthEl.value);
    const heightM = parseFloat(gridHeightEl.value);
    const spacingM = parseFloat(gridSpacingEl.value);
    if (!(widthM > 0) || !(heightM > 0) || !(spacingM > 0)) { clearGrips(); return; }

    const centreEN = latLngToEN(centreLatLng);
    const linesEN = buildGridLinesEN(centreEN, widthM, heightM, spacingM, rotationRad);

    for (const ln of linesEN) {
      const a = enToLatLng(ln.e1, ln.n1);
      const b = enToLatLng(ln.e2, ln.n2);
      L.polyline([a, b], { weight: 2, opacity: 0.85 }).addTo(gridLayer);
    }
  }

  function redrawAll() {
    redrawGrid();
    updateGrips();
    // boundary preview is independent (no need to rebuild on grid changes)
  }

  // ---------------------------
  // DXF export (Grid BLUE, Boundary RED)
  // ---------------------------
  const DXF_COLOR_RED = 1;   // ACI
  const DXF_COLOR_BLUE = 5;  // ACI

  function dxfLineEntity(x1, y1, x2, y2, layer, aciColor) {
    return [
      "0","LINE",
      "8", layer,
      "62", String(aciColor),
      "10", x1.toFixed(3),
      "20", y1.toFixed(3),
      "30", "0.000",
      "11", x2.toFixed(3),
      "21", y2.toFixed(3),
      "31", "0.000"
    ].join("\n") + "\n";
  }

  function dxfLWPolyline(pointsXY, layer, aciColor, closed=false) {
    // pointsXY: [{x,y}, ...]
    const flag = closed ? 1 : 0; // bit 1 = closed
    let out = "";
    out += "0\nLWPOLYLINE\n";
    out += "8\n" + layer + "\n";
    out += "62\n" + String(aciColor) + "\n";
    out += "90\n" + String(pointsXY.length) + "\n";
    out += "70\n" + String(flag) + "\n";
    for (const p of pointsXY) {
      out += "10\n" + p.x.toFixed(3) + "\n";
      out += "20\n" + p.y.toFixed(3) + "\n";
    }
    return out;
  }

  function exportDXF() {
    if (!centreLatLng) { alert("Pick a centre point first."); return; }

    const widthM = parseFloat(gridWidthEl.value);
    const heightM = parseFloat(gridHeightEl.value);
    const spacingM = parseFloat(gridSpacingEl.value);
    const gridLayer = (layerNameEl.value || "GRID").trim();
    const bndLayer = (boundaryLayerNameEl.value || "BOUNDARY").trim();
    const rel = !!relativeExportEl.checked;

    if (!(widthM > 0) || !(heightM > 0) || !(spacingM > 0)) {
      alert("Width, height and spacing must be > 0.");
      return;
    }

    const centreEN = latLngToEN(centreLatLng);

    // Grid lines (absolute EN)
    const linesAbs = buildGridLinesEN(centreEN, widthM, heightM, spacingM, rotationRad);

    const lines = linesAbs.map(l => rel ? ({
      x1: l.e1 - centreEN.e, y1: l.n1 - centreEN.n,
      x2: l.e2 - centreEN.e, y2: l.n2 - centreEN.n
    }) : ({
      x1: l.e1, y1: l.n1,
      x2: l.e2, y2: l.n2
    }));

    // Boundary polyline (if any)
    let boundaryXY = null;
    if (boundaryLatLngs.length >= 2) {
      boundaryXY = boundaryLatLngs.map(ll => {
        const en = latLngToEN(ll);
        return rel ? { x: en.e - centreEN.e, y: en.n - centreEN.n } : { x: en.e, y: en.n };
      });
    }

    let dxf = "";
    dxf += "0\nSECTION\n2\nHEADER\n";
    dxf += "9\n$INSUNITS\n70\n6\n"; // meters
    dxf += "0\nENDSEC\n";
    dxf += "0\nSECTION\n2\nENTITIES\n";

    // Grid BLUE
    for (const ln of lines) {
      dxf += dxfLineEntity(ln.x1, ln.y1, ln.x2, ln.y2, gridLayer, DXF_COLOR_BLUE);
    }

    // Boundary RED
    if (boundaryXY) {
      dxf += dxfLWPolyline(boundaryXY, bndLayer, DXF_COLOR_RED, false);
    }

    dxf += "0\nENDSEC\n0\nEOF\n";

    const blob = new Blob([dxf], { type: "application/dxf" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.style.display = "none";
    a.rel = "noopener";
    a.target = "_blank";

    const deg = (rotationRad * 180 / Math.PI).toFixed(1);
    a.download = `grid_${rel ? "REL" : "OSGB"}_${widthM}x${heightM}_${spacingM}m_${deg}deg.dxf`;

    document.body.appendChild(a);
    a.click();
    // fallback open for mobile
    setTimeout(() => window.open(url, "_blank"), 250);

    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 30000);
  }

  // ---------------------------
  // Picking logic
  // ---------------------------
  function getPickLatLng(tapLatLng) {
    return useCrosshairEl.checked ? crosshairLatLng() : tapLatLng;
  }

  function setCentre(latlng) {
    centreLatLng = latlng;

    if (centreMarker) centreMarker.remove();
    centreMarker = L.marker(centreLatLng, { draggable: true }).addTo(map);
    centreMarker.on('drag', () => {
      centreLatLng = centreMarker.getLatLng();
      if (autoNorthEl.checked && !userRotated) {
        rotationRad = trueNorthRotationRad(centreLatLng);
        updateRotationDisplay();
      }
      redrawAll();
    });

    if (autoNorthEl.checked && !userRotated) {
      rotationRad = trueNorthRotationRad(centreLatLng);
      updateRotationDisplay();
    }

    redrawAll();
  }

  map.on('click', (e) => {
    const picked = getPickLatLng(e.latlng);

    if (mode === 'boundary') {
      boundaryLatLngs.push(picked);
      redrawBoundaryPreview();
      return;
    }

    if (mode === 'centre') {
      setCentre(picked);
      return;
    }

    if (mode === 'rotate') {
      userRotated = true;

      if (!rotatePt1) {
        rotatePt1 = picked;
        const m1 = L.circleMarker(rotatePt1, { radius: 8, weight: 2 }).addTo(map);
        rotateMarkers.push(m1);
        return;
      }
      if (!rotatePt2) {
        rotatePt2 = picked;
        const m2 = L.circleMarker(rotatePt2, { radius: 8, weight: 2 }).addTo(map);
        rotateMarkers.push(m2);

        const p1 = latLngToEN(rotatePt1);
        const p2 = latLngToEN(rotatePt2);
        const thetaFromEast = Math.atan2(p2.n - p1.n, p2.e - p1.e);
        rotationRad = thetaFromEast - (Math.PI / 2);

        updateRotationDisplay();
        redrawAll();

        rotatePt1 = null;
        rotatePt2 = null;
      }
    }
  });

  // ---------------------------
  // Buttons
  // ---------------------------
  document.getElementById('pickCentreBtn').addEventListener('click', () => {
    stopBoundaryMode();
    setMode('centre');
    if (useCrosshairEl.checked) setCentre(crosshairLatLng());
  });

  document.getElementById('pickRotateBtn').addEventListener('click', () => {
    stopBoundaryMode();
    setMode('rotate');
    rotatePt1 = null;
    rotatePt2 = null;
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    stopBoundaryMode();
    centreLatLng = null;
    rotationRad = 0;
    userRotated = false;
    updateRotationDisplay();

    if (centreMarker) { centreMarker.remove(); centreMarker = null; }
    rotateMarkers.forEach(m => m.remove());
    rotateMarkers = [];
    rotatePt1 = null; rotatePt2 = null;

    gridLayer.clearLayers();
    clearGrips();

    // boundary
    boundaryLatLngs = [];
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPreviewLine = null;
    boundaryPointsLayer.clearLayers();
    finishBoundaryBtn.disabled = true;
    clearBoundaryBtn.disabled = true;

    setMode('centre');
  });

  document.getElementById('gpsBtn').addEventListener('click', () => {
    map.locate({ setView: true, maxZoom: 19, enableHighAccuracy: true, timeout: 15000 });
  });

  map.on('locationfound', (e) => {
    stopBoundaryMode();
    setCentre(e.latlng);

    if (window._gpsAccuracy) window._gpsAccuracy.remove();
    window._gpsAccuracy = L.circle(e.latlng, {
      radius: e.accuracy,
      weight: 1,
      opacity: 0.6,
      fillOpacity: 0.08
    }).addTo(map);
  });

  map.on('locationerror', (e) => {
    alert("Couldn't get GPS location: " + (e.message || "permission denied / unavailable"));
  });

  exportBtn.addEventListener('click', exportDXF);

  // Boundary UI
  drawBoundaryBtn.addEventListener('click', () => {
    startBoundaryMode();
  });

  finishBoundaryBtn.addEventListener('click', () => {
    stopBoundaryMode();
  });

  clearBoundaryBtn.addEventListener('click', () => {
    boundaryLatLngs = [];
    if (boundaryPreviewLine) boundaryPreviewLine.remove();
    boundaryPreviewLine = null;
    boundaryPointsLayer.clearLayers();
    finishBoundaryBtn.disabled = true;
    clearBoundaryBtn.disabled = true;
    stopBoundaryMode();
  });

  // Inputs
  gridWidthEl.addEventListener('input', redrawAll);
  gridHeightEl.addEventListener('input', redrawAll);
  gridSpacingEl.addEventListener('input', redrawAll);

  autoNorthEl.addEventListener('change', () => {
    if (centreLatLng && autoNorthEl.checked && !userRotated) {
      rotationRad = trueNorthRotationRad(centreLatLng);
      updateRotationDisplay();
      redrawAll();
    }
  });

  useCrosshairEl.addEventListener('change', () => {
    crosshairEl.style.display = useCrosshairEl.checked ? 'block' : 'none';
  });

  // ---------------------------
  // Draggable bottom sheet (3 snap positions) with desktop fix
  // ---------------------------
  const sheet = document.getElementById('sheet');
  const handle = document.getElementById('handle');

  const snaps = { open: 6, half: 44, closed: 66 };

  let currentSnap = 'half';
  setSheetSnap(currentSnap);

  function setSheetSnap(which) {
    currentSnap = which;
    sheet.style.transform = `translateY(${snaps[which]}vh)`;
    sheet.cl
